(window.webpackJsonp=window.webpackJsonp||[]).push([[294],{753:function(t,a,e){"use strict";e.r(a);var s=e(25),n=Object(s.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"深入浅出-setstate"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#深入浅出-setstate"}},[t._v("#")]),t._v(" 深入浅出 setState")]),t._v(" "),e("h2",{attrs:{id:"前言"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[t._v("#")]),t._v(" 前言")]),t._v(" "),e("p",[t._v("想起自己 8 月份面试时，被面试官们问了好几个 setState 的问题，现在想想，虽然回答上问题了，但是了解的不深刻。我知道 setState 被设计成”异步“是为了性能，但是涉及到源码解读我就歇菜了；我知道如何让它同步，但是遇到真实的代码情况时，却不知道如何下手。说到底，当时是准备了面经把这些概念记下来，而没有真正理解它")]),t._v(" "),e("h2",{attrs:{id:"快速了解"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#快速了解"}},[t._v("#")]),t._v(" 快速了解")]),t._v(" "),e("p",[t._v("基本概念和使用")]),t._v(" "),e("p",[t._v("关键知识点：")]),t._v(" "),e("ul",[e("li",[t._v("setState 不会立即改变 React 组件中 state 的值")]),t._v(" "),e("li",[t._v("setState 通过引发一次组件的更新过程来引发重新绘制")]),t._v(" "),e("li",[t._v("多次 setState 函数调用产生的效果会合并")])]),t._v(" "),e("p",[t._v("setState 什么时候能同步")]),t._v(" "),e("ul",[e("li",[t._v("addEventListener 绑定的原生事件处理、setTimeout/setInterval")])]),t._v(" "),e("p",[t._v("执行原理")]),t._v(" "),e("p",[t._v("有一答一")]),t._v(" "),e("p",[t._v("来几个面试题")]),t._v(" "),e("p",[t._v("为什么不直接同步而要塞入队列中，一起做处理，原理是什么？")]),t._v(" "),e("ul",[e("li",[t._v("性能")])]),t._v(" "),e("p",[t._v("假设每次 setState 就要更新数据，更新过程要走四个生命周期，走完一轮生命周期")]),t._v(" "),e("p",[t._v("render 函数的结果要拿去做 diff 对比和更新真实 DOM，这个就很耗时间")]),t._v(" "),e("p",[t._v("所以将它每次调用都放在一起一次性处理，能将对 DOM 操作降到最小，提高性能")]),t._v(" "),e("h2",{attrs:{id:"基本概念和使用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#基本概念和使用"}},[t._v("#")]),t._v(" 基本概念和使用")]),t._v(" "),e("p",[t._v("React 的理念之一是 UI=f(data)，修改 data 即驱动 UI 变化，那么怎么修改呢？React 提供了一个 API ——setState")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://zh-hans.reactjs.org/docs/react-component.html#setstate",target:"_blank",rel:"noopener noreferrer"}},[t._v("官网介绍"),e("OutboundLink")],1),t._v("：")]),t._v(" "),e("blockquote",[e("p",[e("code",[t._v("setState()")]),t._v(" 将对组件 state 的更新排入队列，并通知 React 需要使用更新后的 state 重新渲染此组件及其子组件。这是用于更新用户界面以响应事件处理器和处理服务器数据的主要方式")]),t._v(" "),e("p",[t._v("为了更好的感知性能，React 会延迟调用它，然后通过一次传递更新多个组件。React 并不会保证 state 的变更会立即生效")]),t._v(" "),e("p",[e("code",[t._v("setState()")]),t._v(" 并不总是立即更新组件。它会批量推迟更新。这使得在调用 "),e("code",[t._v("setState()")]),t._v(" 后立即读取 "),e("code",[t._v("this.state")]),t._v(" 成为了隐患。为了消除隐患，请使用 "),e("code",[t._v("componentDidUpdate")]),t._v(" 或者 "),e("code",[t._v("setState")]),t._v(" 的回调函数（"),e("code",[t._v("setState(updater, callback)")]),t._v("），这两种方式都可以保证在应用更新后触发")]),t._v(" "),e("p",[t._v("除非 "),e("code",[t._v("shouldComponentUpdate()")]),t._v(" 返回 "),e("code",[t._v("false")]),t._v("，否则 "),e("code",[t._v("setState()")]),t._v(" 将始终执行重新渲染操作。如果可变对象被使用，且无法在 "),e("code",[t._v("shouldComponentUpdate()")]),t._v(" 中实现条件渲染，那么仅在新旧状态不一时调用 "),e("code",[t._v("setState()")]),t._v("可以避免不必要的重新渲染")])]),t._v(" "),e("h3",{attrs:{id:"使用方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#使用方法"}},[t._v("#")]),t._v(" 使用方法")]),t._v(" "),e("p",[t._v("setState(updater[, callback])")]),t._v(" "),e("p",[t._v("参数一为带有形式参数的 updater 函数：")]),t._v(" "),e("div",{staticClass:"language-javascript extra-class"},[e("pre",{pre:!0,attrs:{class:"language-javascript"}},[e("code",[e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("state"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" props")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" stateChange\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 例如")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// this.setState((state, props) => {")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//   return {counter: state.counter + props.step};")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// });")]),t._v("\n")])])]),e("p",[t._v("setState() 的第一个参数除了接受函数外，还可以接受对象类型：")]),t._v(" "),e("div",{staticClass:"language-javascript extra-class"},[e("pre",{pre:!0,attrs:{class:"language-javascript"}},[e("code",[e("span",{pre:!0,attrs:{class:"token function"}},[t._v("setState")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("stateChange"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" callback"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 例如：this.setState({count: 2})")]),t._v("\n")])])]),e("p",[t._v("setState() 的第二个参数位可选的回调函数，它将在 setState 完成合并重新渲染组件后执行。通常，我们建议使用 componentDidUpdate 来代替此方法")]),t._v(" "),e("p",[t._v("为什么？")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://stackoverflow.com/questions/56501409/what-is-the-advantage-of-using-componentdidupdate-over-the-setstate-callback",target:"_blank",rel:"noopener noreferrer"}},[t._v("stackoverflow"),e("OutboundLink")],1),t._v(" 有人问过，也有人回答过：")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("一致的逻辑")])]),t._v(" "),e("li",[e("p",[t._v("批量更新")])])]),t._v(" "),e("p",[t._v("什么时候 setState 会比较好？")]),t._v(" "),e("p",[t._v("当外部代码需要等待状态更新时")]),t._v(" "),e("p",[t._v("如果在同意周期内对多个 setState 进行处理，例如，在同一周期内多次设置商品数据，相当于：")]),t._v(" "),e("div",{staticClass:"language-javascript extra-class"},[e("pre",{pre:!0,attrs:{class:"language-javascript"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("setState")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("count"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" state"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("count "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("setState")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("count"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" state"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("count "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("setState")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("count"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" state"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("count "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// === ")]),t._v("\nObject"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("assign")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n  count"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("quantity"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" state"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("quantity "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("quantity"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" state"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("quantity "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("...")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),e("p",[t._v("后调的 setState 将覆盖同一周期内先调用 setState 的值")]),t._v(" "),e("ul",[e("li",[t._v("setState(stateChange[, callback])")]),t._v(" "),e("li",[t._v("setState((state, props) => stateChange[, callback])")])]),t._v(" "),e("p",[t._v("setState必引发更新过程，但不一定会引发render被执行，因为shouldCompomentUpdate可以返回false")]),t._v(" "),e("h2",{attrs:{id:"常见的问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#常见的问题"}},[t._v("#")]),t._v(" 常见的问题")]),t._v(" "),e("h3",{attrs:{id:"问题一"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#问题一"}},[t._v("#")]),t._v(" 问题一：")]),t._v(" "),e("div",{staticClass:"language-react extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("this.setState({count: state.count + 1}); \nthis.setState({count: state.count + 1}); \nthis.setState({count: state.count + 1}); \n// state.count === 1，不是 3\n")])])]),e("p",[t._v("setState是异步的？")]),t._v(" "),e("p",[t._v("为什么setState是异步的？这样设计的目的是什么？")]),t._v(" "),e("p",[t._v("如何实现异步的setState，设计思路是什么？")]),t._v(" "),e("p",[t._v("为了性能，")]),t._v(" "),e("p",[t._v("因为浏览器是单线程，我举个例子，如果你点击，而这个点击方法里延迟3秒，那么用户再在三秒里是不能做什么事情的，这样的用户体验是极差的，所以react在设计setState的时候会把setState设计成异步。")]),t._v(" "),e("p",[t._v("每一次setState如果都会引发一次组件更新，走完一圈生命周期，实在是有点粗糙和浪费")]),t._v(" "),e("p",[t._v("如何设计我就没思路了")]),t._v(" "),e("h4",{attrs:{id:"为什么要-setstate-而不是直接-this-state-xx-oo"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#为什么要-setstate-而不是直接-this-state-xx-oo"}},[t._v("#")]),t._v(" 为什么要 setState，而不是直接 this.state.xx = oo?")]),t._v(" "),e("p",[t._v("我们知道在 vue 中的修改状态是可以直接修改的。为什么在react中不行")]),t._v(" "),e("p",[t._v("因为 setState 做的事情不仅只是修改了 "),e("code",[t._v("this.state")]),t._v(" 的值，另外最重要的是它会触发 React 的更新机制，会进行diff，然后将 patch 部分更新到真实 dom 里。")]),t._v(" "),e("p",[t._v("如果你直接 "),e("code",[t._v("this.state.xx = oo")]),t._v(" 的话，state 的值确实会改，但是改了不会触发 UI 的更新，那就不是数据驱动了。")]),t._v(" "),e("p",[t._v("那为什么Vue直接修改 data 可以触发 UI 的更新呢？ 因为 Vue 在创建 UI 的时候会把这些 data 给收集起来，并且在这些 data 的访问器属性 setter 进行了重写，在这个重写的方法里会去触发 UI 的更新")]),t._v(" "),e("p",[t._v("目前React会将setState的效果放在队列中，积攒着一次引发更新过程，为的就是把Virtual DOM和DOM树操作降到最小，用于提高性能")]),t._v(" "),e("h2",{attrs:{id:"setstate-的大纲笔记"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#setstate-的大纲笔记"}},[t._v("#")]),t._v(" setState 的大纲笔记")]),t._v(" "),e("ol",[e("li",[e("p",[t._v("setState 不会立刻改变 React 组件中 state 的值")]),t._v(" "),e("ol",[e("li",[t._v("因为批处理")]),t._v(" "),e("li",[t._v("修改 this.state 值是没有意义的，它不会驱动 react 重渲染")]),t._v(" "),e("li",[t._v("setState 函数能帮助我们更新视图，引发 componentDidMount、render 等一系列函数的调用")])])]),t._v(" "),e("li",[e("p",[t._v("setState 通过引发一次组件的更新过程来引发重新绘制")]),t._v(" "),e("ol",[e("li",[e("p",[t._v("使用 setState 后，会触发 render")])]),t._v(" "),e("li",[e("p",[t._v("react 不像 vue，vue 是通过数据劫持来实现数据变化视图跟着更新，react 需要通过调用 setState 来render")]),t._v(" "),e("ol",[e("li",[t._v("React 改变状态时通过一个函数 setState 驱动的，和 vue 不同")])])]),t._v(" "),e("li",[e("p",[t._v("setState 调用引起的React的更新生命周期函数4个函数（比修改 props 引发的生命周期少一个componentWillReceiveProps函数），这4个函数一次被调用")]),t._v(" "),e("ol",[e("li",[e("p",[t._v("shouldComponentUpdate")])]),t._v(" "),e("li",[e("p",[t._v("componentWillUpdate")])]),t._v(" "),e("li",[e("p",[t._v("render")])]),t._v(" "),e("li",[e("p",[t._v("componentDidUpdate")]),t._v(" "),e("p",[t._v("this.state 只有在render函数被调用后才更新")]),t._v(" "),e("p",[t._v("不管你喜欢不喜欢，反正this.state就是不会再this.setState调用之后立刻更新")])])])])])]),t._v(" "),e("li",[e("p",[t._v("多次setState函数调用产生的效果会合并。")]),t._v(" "),e("ol",[e("li",[t._v("批处理")]),t._v(" "),e("li",[t._v("原因如上所示，只有调用this.setState才会更新试图（render 的时候更新数据），所以为了性能，每次更新过程中，会把积攒的setState结果合并（react会将多个this.setState产生的修改放在一个队列里，最后批处理）")])])]),t._v(" "),e("li",[e("p",[t._v("setState中能传入函数")]),t._v(" "),e("ol",[e("li",[t._v("传入函数的话，就能实现同步")])])]),t._v(" "),e("li",[e("p",[t._v("this.setState 能同步")]),t._v(" "),e("ol",[e("li",[t._v("在React中，"),e("strong",[t._v("如果是由React引发的事件处理（比如通过onClick引发的事件处理），调用setState不会同步更新this.state，除此之外的setState调用会同步执行this.state")]),t._v("。所谓“除此之外”，指的是绕过React通过addEventListener直接添加的事件处理函数，还有通过setTimeout/setInterval产生的异步调用。")])])])]),t._v(" "),e("h2",{attrs:{id:"执行原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#执行原理"}},[t._v("#")]),t._v(" 执行原理")]),t._v(" "),e("p",[t._v("this.setState 之后，触发更新。"),e("a",{attrs:{href:"https://zh-hans.reactjs.org/docs/react-component.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("更新的生命周期调用顺序如下"),e("OutboundLink")],1),t._v("：")]),t._v(" "),e("ul",[e("li",[t._v("static getDerivedStateFromProps")]),t._v(" "),e("li",[t._v("shouldComponentUpdate")]),t._v(" "),e("li",[t._v("UNSAFE_componentWillUpdate")]),t._v(" "),e("li",[t._v("render")]),t._v(" "),e("li",[t._v("getSnapshotBeforeUpdate")]),t._v(" "),e("li",[t._v("componentDidUpdate")])]),t._v(" "),e("p",[t._v("在 React 的 setState 函数实现中，会根据一个变量 isBatchingUpdates 判断是直接更新 this.state 还是放到队列中回头再说，而 isBatchingUpdates 默认是 false，也就表示 setState 会同步更新 this.state，但是，有一个函数 batchedUpdates，这个函数会把 isBatchingUpdates 修改为 true，而当 React 在调用事件处理函数之前就会调用这个 batchedUpdates，造成的后果，就是由 React 控制的事件处理过程 setState 不会同步更新 this.state")]),t._v(" "),e("p",[t._v("源码：")]),t._v(" "),e("div",{staticClass:"language-react extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("Component.prototype.setState = function(partialState, callback) {\n  invariant(\n    typeof partialState === 'object' ||\n      typeof partialState === 'function' ||\n      partialState == null,\n    'setState(...): takes an object of state variables to update or a ' +\n      'function which returns an object of state variables.',\n  );\n  this.updater.enqueueSetState(this, partialState, callback, 'setState');\n};\n")])])]),e("div",{staticClass:"language-javascript extra-class"},[e("pre",{pre:!0,attrs:{class:"language-javascript"}},[e("code",[e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ReactComponent")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("prototype"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("setState")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("partialState"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" callback")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("updater"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("enqueueSetState")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" partialState"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("callback"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("updater"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("enqueueCallback")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" callback"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("'setState'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),e("h2",{attrs:{id:"有一答一"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#有一答一"}},[t._v("#")]),t._v(" 有一答一")]),t._v(" "),e("ol",[e("li",[t._v("setState 是同步还是异步？")])]),t._v(" "),e("p",[t._v("我的回答是执行过程代码同步，只要合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形成了所谓的“异步”，所以表现出来有时候同步，有时候异步")]),t._v(" "),e("ol",{attrs:{start:"2"}},[e("li",[t._v("何时是同步，何时是异步？")])]),t._v(" "),e("p",[t._v("只在合成事件和钩子函数中是“异步”的，在原生事件和 setTimeout/setInterval 等原生API 中都是同步的。简单的可以理解为被 React 控制的函数里面就会表现出“异步”，反之表现为同步。")]),t._v(" "),e("ol",{attrs:{start:"3"}},[e("li",[t._v("那为什么会出现异步的情况呢？（为什么这么设计？）")])]),t._v(" "),e("p",[t._v("为了做性能优化，将 state 的更新延缓到最后批量合并再去渲染，对于应用的性能优化有极大好处。如果每次的状态更改都去重新渲染真实 dom，那么它将带来巨大的性能消耗")]),t._v(" "),e("ol",{attrs:{start:"4"}},[e("li",[t._v("那如何在表现出异步的函数里可以准确拿到更新后的 state 呢？")])]),t._v(" "),e("p",[t._v("通过第二个参数 "),e("code",[t._v("setState(partialState, callback)")]),t._v(" 中的 callback 拿到更新后的结果")]),t._v(" "),e("p",[t._v("或者可以直接给 state 传递函数来表现出同步的情况")]),t._v(" "),e("div",{staticClass:"language-javascript extra-class"},[e("pre",{pre:!0,attrs:{class:"language-javascript"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("setState")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("state")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" val"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" newVal "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),e("ol",{attrs:{start:"5"}},[e("li",[t._v("那表现出异步的原理是怎么样的？")])]),t._v(" "),e("p",[t._v("在 React 的 setState 函数实现中，会根据 isBatchingUpdates（默认是 false） 变量判断是否直接更新 this.state 还是放到队列中稍后更新。然后有一个 batchedUpdate 函数，可以修改 isBatchingUpdates 为 true，当 React 调用事件处理函数之前，或者生命周期函数之前就会调用 batchedUpdate 函数，这样的话，setState 就不会同步更新 this.state，而是放到更新队列里面后续更新。")]),t._v(" "),e("p",[t._v("这样你就可以理解为什么原生事件和 setTimeout/setInterval 里面调用 this.state 会同步更新了吧，因为通过这些函数调用的 React 没办法去调用 batchedUpdate 函数将 isBatchingUpdates 设置为 true，那么这个时候 setState 的时候默认就是 false，那么就会同步更新。")]),t._v(" "),e("h2",{attrs:{id:"来几个面试题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#来几个面试题"}},[t._v("#")]),t._v(" 来几个面试题")]),t._v(" "),e("p",[t._v("第一个，也是我在面试中遇到的。如下的代码，它的 a 的值是多少？又 render 了几次")]),t._v(" "),e("div",{staticClass:"language-react extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('class C extends React.Component {\n  state = {\n    a: 0\n  };\n  componentDidMount() {\n    this.setState({ a: 1 });\n    setTimeout(() => {\n      this.setState({ a: 2 });\n    }, 0);\n    new Promise((resolve) => {\n      resolve(this.setState({ a: 3 }));\n    }).then(() => {\n      this.setState({ a: 4 });\n    });\n  }\n  render() {\n    console.log("state", this.state);\n    return <div>{this.state.a}</div>;\n  }\n}\n')])])]),e("div",{staticClass:"language-react extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('class App extends React.Component {\n  state = {\n    val: 0\n  };\n  componentDidMount() {\n    this.setState({ val: this.state.val + 1 });\n    console.log(this.state.val);\n    this.setState({ val: this.state.val + 1 });\n    console.log(this.state.val);\n    setTimeout(() => {\n      console.log(this.state.val);\n      this.setState({ val: this.state.val + 1 });\n      console.log(this.state.val);\n      this.setState({ val: this.state.val + 1 });\n      console.log(this.state.val);\n    }, 0);\n  }\n  render() {\n    return <div className="App">{this.state.val}</div>;\n  }\n}\n')])])]),e("p",[t._v("可以在这里查看 "),e("a",{attrs:{href:"https://codesandbox.io/s/setstate-216l6?file=/src/App.js",target:"_blank",rel:"noopener noreferrer"}},[t._v("demo"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("答案是 0、0、1、2、3")]),t._v(" "),e("h2",{attrs:{id:"参考资料"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[t._v("#")]),t._v(" 参考资料")]),t._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/25954470",target:"_blank",rel:"noopener noreferrer"}},[t._v("setState：这个API设计到底怎么样"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/25990883",target:"_blank",rel:"noopener noreferrer"}},[t._v("setState为什么不会同步更新组件状态"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/26069727",target:"_blank",rel:"noopener noreferrer"}},[t._v("setState何时同步更新状态"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://segmentfault.com/a/1190000015615057",target:"_blank",rel:"noopener noreferrer"}},[t._v("浅入深出setState（上篇）"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://segmentfault.com/a/1190000015821018",target:"_blank",rel:"noopener noreferrer"}},[t._v("浅入深出setState（下篇）"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://keqingrong.cn/blog/2019-04-01-react-setstate",target:"_blank",rel:"noopener noreferrer"}},[t._v("重新认识 React 的 setState"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/39512941",target:"_blank",rel:"noopener noreferrer"}},[t._v("你真的理解setState吗？"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://mp.weixin.qq.com/s/my2Jx7pcbVYnaCWklAzKXA",target:"_blank",rel:"noopener noreferrer"}},[t._v("setState 到底是同步的，还是异步的"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://segmentfault.com/a/1190000040445026",target:"_blank",rel:"noopener noreferrer"}},[t._v("React 中 setState 是一个宏任务还是微任务？"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://stackoverflow.com/questions/56501409/what-is-the-advantage-of-using-componentdidupdate-over-the-setstate-callback",target:"_blank",rel:"noopener noreferrer"}},[t._v("What is the advantage of using componentDidUpdate over the setState callback?"),e("OutboundLink")],1)])])])}),[],!1,null,null,null);a.default=n.exports}}]);