(window.webpackJsonp=window.webpackJsonp||[]).push([[339],{796:function(v,_,t){"use strict";t.r(_);var e=t(25),p=Object(e.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"javascript-设计模式核心原理笔记"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#javascript-设计模式核心原理笔记"}},[v._v("#")]),v._v(" JavaScript 设计模式核心原理笔记")]),v._v(" "),t("h3",{attrs:{id:"核心思想"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#核心思想"}},[v._v("#")]),v._v(" 核心思想")]),v._v(" "),t("p",[v._v("​\tSOLID 设计原则")]),v._v(" "),t("blockquote",[t("p",[v._v("​\t\t“SOLID”是由罗伯特·C·马丁在 21 世纪早期引入的记忆术首字母缩略字，指代了面向对象编程和面向对象设计的五个基本原则。")])]),v._v(" "),t("p",[v._v("分别是：")]),v._v(" "),t("ul",[t("li",[v._v("单一功能原则（Single Responsibility Principle）")]),v._v(" "),t("li",[v._v("开发封闭原则（Opened Closed Principle）")]),v._v(" "),t("li",[v._v("里市替换原则（Liskov Substitution Principle)")]),v._v(" "),t("li",[v._v("接口隔离原则（Interface Segregation Principle）")]),v._v(" "),t("li",[v._v("依赖反转原则（Dependency Inversion Principle）")])]),v._v(" "),t("h4",{attrs:{id:"设计模式的核心思想-封装变化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#设计模式的核心思想-封装变化"}},[v._v("#")]),v._v(" 设计模式的核心思想——封装变化")]),v._v(" "),t("p",[v._v("将变与不变分离，确保变化的部分灵活、不变的部分稳定")]),v._v(" "),t("h3",{attrs:{id:"设计模式中的-术"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#设计模式中的-术"}},[v._v("#")]),v._v(" 设计模式中的“术”")]),v._v(" "),t("p",[v._v("二十年前，四位程序员前辈（Erich Gamma, Richard Helm, Ralph Johnson & John Vlissides）通过编写《设计模式：可复用面向对象软件的基础》这本书， 阐述了设计模式领域的开创性成果。在这本书中，将23种设计模式按照“创建型”、“行为型”和“结构型”进行划分：")]),v._v(" "),t("p",[t("img",{attrs:{src:"https://i.loli.net/2021/06/03/Pjf1Au3QMev74ca.png",alt:"23种设计模式"}})]),v._v(" "),t("p",[v._v("无论是创建型、结构型还是行为型，这些具体的设计模式都是在用自己的方式去封装不同类型的变化。")]),v._v(" "),t("p",[v._v("​\t创建型模式封装了创建对象过程中的变化，比如工厂模式，他做的事情就是讲创建对象的过程抽离;")]),v._v(" "),t("p",[v._v("​\t结构型模式封装的是对象之间组合方式的变化，目的在于灵活地表达对象间的配合与依赖关系；")]),v._v(" "),t("p",[v._v("​\t行为型模式则将是对象千变万化的行为进行抽离，确保我们能够更安全、更方便地对行为进行更改")]),v._v(" "),t("p",[v._v("设计原则")]),v._v(" "),t("p",[v._v("分类依据")]),v._v(" "),t("p",[v._v("创建型")]),v._v(" "),t("p",[v._v("工厂模式")]),v._v(" "),t("p",[v._v("抽象工厂模式")]),v._v(" "),t("p",[v._v("原型模式")]),v._v(" "),t("p",[v._v("结构型")]),v._v(" "),t("p",[v._v("装饰器模式")]),v._v(" "),t("p",[v._v("适配器模式")]),v._v(" "),t("p",[v._v("代理模式")]),v._v(" "),t("p",[v._v("行为型")]),v._v(" "),t("p",[v._v("观察者模式")]),v._v(" "),t("p",[v._v("策略模式")]),v._v(" "),t("p",[v._v("状态模式")]),v._v(" "),t("p",[v._v("迭代器模式")]),v._v(" "),t("p",[v._v("思考：")]),v._v(" "),t("p",[v._v("实例和类的关系")]),v._v(" "),t("p",[v._v("为什么要有实例")]),v._v(" "),t("p",[v._v("为什么不能用类来实现代码")]),v._v(" "),t("p",[v._v("new Function()")]),v._v(" "),t("p",[v._v("new Error()")]),v._v(" "),t("p",[v._v("new Array()")]),v._v(" "),t("p",[v._v("new Object()")]),v._v(" "),t("p",[v._v("...")]),v._v(" "),t("p",[v._v("为什么要 new 它，为什么要实例化它")])])}),[],!1,null,null,null);_.default=p.exports}}]);