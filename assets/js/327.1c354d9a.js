(window.webpackJsonp=window.webpackJsonp||[]).push([[327],{785:function(t,a,e){"use strict";e.r(a);var s=e(25),n=Object(s.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"源码分析react-router源码"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#源码分析react-router源码"}},[t._v("#")]),t._v(" 源码分析React Router源码")]),t._v(" "),e("h2",{attrs:{id:"前端路由前世今生"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#前端路由前世今生"}},[t._v("#")]),t._v(" 前端路由前世今生")]),t._v(" "),e("p",[t._v("前端路由发展到今天，经历了后端路由、前后端路由过渡、前端路由的过程")]),t._v(" "),e("h3",{attrs:{id:"后端路由"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#后端路由"}},[t._v("#")]),t._v(" 后端路由")]),t._v(" "),e("p",[t._v("这个时期，不管 Web 后端是什么语言的框架，都会有一个专门开辟出来的路由模块或者路由区域，用来匹配用户给出的 URL 地址，以及一些表单提交、页面请求地址。用户进行页面切换时，浏览器发送不同的 URL 请求，服务器接收到浏览器的请求时，通过解析不同的 URL 地址进行后端路由匹配，将模板拼接好后将之返回给前端完整的 HTML，浏览器拿到这个 HTML 文件后直接解析展示了，也就是所谓的服务端渲染")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://i.loli.net/2021/06/16/Fit7zNHclqfOTKZ.png",alt:"后端路由过程"}})]),t._v(" "),e("p",[t._v("服务端渲染页面，后端有完整的 HTML 页面，爬虫更容易获取信息，有利于 SEO 优化。对于客户端的资源占用更少，尤其是移动端，可以更省流量")]),t._v(" "),e("h3",{attrs:{id:"过渡"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#过渡"}},[t._v("#")]),t._v(" 过渡")]),t._v(" "),e("p",[t._v("Ajax 的基本概念（XMLHttpRequest 的前身）")]),t._v(" "),e("p",[t._v("单页应用不仅在页面交互是无刷新的，连页面跳转都是无刷新的，为了配合实现单页面应用跳转，前端路由孕育而生。")]),t._v(" "),e("h3",{attrs:{id:"前端路由"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#前端路由"}},[t._v("#")]),t._v(" 前端路由")]),t._v(" "),e("p",[t._v("前端路由的兴起，使得页面渲染由服务器渲染变成了前端渲染。为什么这么说呢！请求一个 URL 地址时，服务器不需要拼接模板，只需返回一个 HTML 即可，一般浏览器拿到的 HTML 是这样的：")]),t._v(" "),e("div",{staticClass:"language-html extra-class"},[e("pre",{pre:!0,attrs:{class:"language-html"}},[e("code",[e("span",{pre:!0,attrs:{class:"token doctype"}},[e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<!")]),e("span",{pre:!0,attrs:{class:"token doctype-tag"}},[t._v("DOCTYPE")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token name"}},[t._v("html")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("html")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("lang")]),e("span",{pre:!0,attrs:{class:"token attr-value"}},[e("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')]),t._v("en"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')])]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("head")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("meta")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("charset")]),e("span",{pre:!0,attrs:{class:"token attr-value"}},[e("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')]),t._v("UTF-8"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')])]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("title")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("Demo"),e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("title")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("link")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("href")]),e("span",{pre:!0,attrs:{class:"token attr-value"}},[e("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')]),t._v("app.css"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')])]),t._v(" "),e("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("rel")]),e("span",{pre:!0,attrs:{class:"token attr-value"}},[e("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')]),t._v("stylesheet"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')])]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("/>")])]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("head")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("body")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("div")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("id")]),e("span",{pre:!0,attrs:{class:"token attr-value"}},[e("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')]),t._v("app"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')])]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("div")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("script")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("type")]),e("span",{pre:!0,attrs:{class:"token attr-value"}},[e("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')]),t._v("text/javascript"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')])]),t._v(" "),e("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("src")]),e("span",{pre:!0,attrs:{class:"token attr-value"}},[e("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')]),t._v("app.js"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')])]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),e("span",{pre:!0,attrs:{class:"token script"}}),e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("script")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("body")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("html")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n")])])]),e("p",[t._v("这里空荡荡的只有一个"),e("code",[t._v('<div id="app"></div>')]),t._v("，以及一系列的 js 文件，所以说这个 HTML 是不完整的。我们看到的页面是通过这一系列的 js 渲染出来的，也就是前端渲染。前端渲染通过客户端的算力来解决页面的构建，很大程度上缓解了服务端的压力")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://i.loli.net/2021/06/16/xw5eLQZEt2KCiyq.png",alt:"前端路由过程"}})]),t._v(" "),e("p",[t._v("单页面开发是趋势，但也不能避重就轻，忽略前端渲染的缺点。由于服务器没有保留完整的 HTML，通过 js 进行动态 DOM 拼接，需要耗费额外的时间，不如服务端渲染速度快，也不利于 SEO 优化。所以说，实际开发中，不能盲目选择渲染方式，一定要基于业务场景。对于没有复杂交互，SEO 要求严格的网站，服务器渲染也是正确的选择")]),t._v(" "),e("h2",{attrs:{id:"核心原理解析"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#核心原理解析"}},[t._v("#")]),t._v(" 核心原理解析")]),t._v(" "),e("h3",{attrs:{id:"react-router-dom"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react-router-dom"}},[t._v("#")]),t._v(" react-router-dom")]),t._v(" "),e("p",[t._v("react-router 的注入方式是在组件树顶层放一个 Router 组件，然后在组件树种散落着很多 Route 组件，顶层的 Router 组件负责分析监听 URL 的变化，在其下面的 Route 组件渲染对应的组件")]),t._v(" "),e("h3",{attrs:{id:"react-router-用法回顾"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react-router-用法回顾"}},[t._v("#")]),t._v(" React Router 用法回顾")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://i.loli.net/2021/06/16/HvP9UhJQyToRij8.png",alt:"React-router组件"}})]),t._v(" "),e("ul",[e("li",[e("strong",[t._v("路由器组件")]),t._v(": "),e("code",[t._v("<BrowserRouter>")]),t._v(" 和 "),e("code",[t._v("<HashRouter>")]),t._v("，路由器组件的作为根容器组件，"),e("code",[t._v("<Route>")]),t._v(" 等路由组件必须被包裹在内才能够使用。")]),t._v(" "),e("li",[e("strong",[t._v("路由匹配组件")]),t._v(": "),e("code",[t._v("<Route>")]),t._v(" 和 "),e("code",[t._v("<Switch>")]),t._v("，路由匹配组件通过匹配 path，渲染对应组件。")]),t._v(" "),e("li",[e("strong",[t._v("导航组件")]),t._v(": "),e("code",[t._v("<Link>")]),t._v(" 和 "),e("code",[t._v("<NavLink>")]),t._v("，导航组件起到类似 "),e("code",[t._v("a")]),t._v(" 标签跳转页面的作用。在后续对源码的讲解中，也将分别以这六个组件代码的解析为线索，来一窥 React Router 的整体实现。看回我们的代码，对于我们开头实现的原生路由，如果用 React Router 改写，应该是怎样的写法呢：")])]),t._v(" "),e("div",{staticClass:"language-react extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('import { BrowserRouter, Switch, Route, Link } from "react-router-dom";\n// HashRouter 和 BrowserRouter 二者的使用方法几乎没有差别，这里只演示其一\n\nconst App = () => {\n  return (\n    <BrowserRouter>\n        <Link to="/">Home</Link>\n        <Link to="/about">About</Link>\n        <Link to="/user">User</Link>\n\n        <Switch>\n            <Route path="/about"><About /></Route>\n            <Route path="/user"> <User /></Route>\n            <Route path="/"><Home /></Route>\n        </Switch>\n    </BrowserRouter>\n  );\n}\n\nconst Home = () => (<h2>Home</h2>);\nconst About = () => (<h2>About</h2>);\nconst User = () => (<h2>User</h2>);\n\nexport default App;\n')])])]),e("h2",{attrs:{id:"react-router-源码实现"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react-router-源码实现"}},[t._v("#")]),t._v(" React Router 源码实现")]),t._v(" "),e("p",[t._v("先用最简单的话来概括一下 React Router 到底做了什么？")]),t._v(" "),e("p",[e("strong",[t._v("本质上， React Router 就是在页面 URL 发生变化的时候，通过我们写的 path 去匹配，然后渲染对应的组件。")])]),t._v(" "),e("p",[t._v("那么，我们想一下如何分步骤实现：")]),t._v(" "),e("ol",[e("li",[t._v("如何监听 url 的变化 ？")]),t._v(" "),e("li",[t._v("如何匹配 path ？")]),t._v(" "),e("li",[t._v("渲染对应的组件")])]),t._v(" "),e("p",[t._v("换句话说，也是一个组件，通过渲染不同的组件来控制路由切换")]),t._v(" "),e("h3",{attrs:{id:"整体设计"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#整体设计"}},[t._v("#")]),t._v(" 整体设计")]),t._v(" "),e("p",[t._v("我们用一张图来理解一下整个 react-router 是怎么实现的：")]),t._v(" "),e("p",[t._v("接下来我们看看每一个步骤是怎么实现的。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://i.loli.net/2021/06/16/LdX43GNEtSCMjI2.png",alt:"640"}})]),t._v(" "),e("h3",{attrs:{id:"如何监听-url-的变化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#如何监听-url-的变化"}},[t._v("#")]),t._v(" 如何监听 url 的变化 ？")]),t._v(" "),e("p",[t._v("正常情况下，当 URL 发生变化时，浏览器会像服务端发送请求，但使用以下2种办法不会向服务端发送请求：")]),t._v(" "),e("ul",[e("li",[t._v("基于 hash")]),t._v(" "),e("li",[t._v("基于 history")])]),t._v(" "),e("p",[t._v("react-router 使用了 history 这个核心库。")]),t._v(" "),e("p",[t._v("而 history 库的本质是通过前文所说的")]),t._v(" "),e("p",[t._v("要想了解 React-Router 的本质，就要依次解决这三个问题")]),t._v(" "),e("ol",[e("li",[t._v("单页面应用路由的实现原理是什么？")]),t._v(" "),e("li",[t._v("React-router 是如何跟 React 结合起来的？")])]),t._v(" "),e("p",[t._v("而后我们可以实现一个简单的 React-router")]),t._v(" "),e("p",[t._v("React-Router 借用了 history 解决了第一个问题")]),t._v(" "),e("p",[t._v("用 React.createContext 解决了第二个问题")]),t._v(" "),e("p",[e("code",[t._v("<Router>")]),t._v(" 只做了两件事，一是给子组件包了一层 "),e("code",[t._v("context")]),t._v("，让路由信息（ history 和 location 对象）能传递给其下所有子孙组件；二是绑定了路由监听事件，使每次路由的改变都触发"),e("code",[t._v("setState")])]),t._v(" "),e("p",[t._v("实现 ReactRouter 前，先去看一下 ReactRouter 的写法")]),t._v(" "),e("div",{staticClass:"language-react extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('<Switch>\n      <Route exact path="/" component={Home}/>\n      <Route path="/about" component={About}/>\n      <Route path="/topics" component={Topics} />\n      <Route render={(props) => {\n        return <pre>URL: {JSON.stringify(props.match.url)}</pre>\n      }} />\n</Switch>\t\n')])])]),e("blockquote",[e("p",[t._v("BrowseHistory 必须依赖服务器让 url 都映射到 index.html ，否则会 404 。")])]),t._v(" "),e("p",[t._v("注意到了没，Switch 是一个组件，Route 也是一个组件")]),t._v(" "),e("p",[t._v("这就好比")]),t._v(" "),e("div",{staticClass:"language-react extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("class Route extends React.Component {\n   render() {\n       const { exact, path, component, children,render } = this.props;\n       \n       const match = matchPath(location.pathname, {\n           path,\n           exact\n       })\n       \n       if (!match) {\n           return null\n       }\n       \n       if (component) {\n           return React.createElement(component, { match })\n       }\n       \n       if (render) {\n           return (\n               render({ match })\n           )\n       }\n       return (\n         null\t\n       )\n   }\n}\n")])])]),e("p",[t._v("主要是")]),t._v(" "),e("div",{staticClass:"language-react extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("<RouterContext.Provider\n    value={{\n        history: this.props.history,\n            location: this.state.location,\n                match: Router.computeRootMatch(this.state.location.pathname),\n                    staticContext: this.props.staticContext\n    }}\n    >\n    <HistoryContext.Provider\n        children={this.props.children || null}\n        value={this.props.history}\n    />\n</RouterContext.Provider>\n")])])]),e("h3",{attrs:{id:"route-的实现"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#route-的实现"}},[t._v("#")]),t._v(" Route 的实现")]),t._v(" "),e("p",[t._v("我们前面提到，前端路由的核心在于监听和匹配，上面我们使用 "),e("code",[t._v("<Router>")]),t._v(" 实现了监听，那么本小节就来分析 "),e("code",[t._v("<Route>")]),t._v(" 是如何做匹配的，同样地我们先回顾 "),e("code",[t._v("<Route>")]),t._v(" 的用法：")]),t._v(" "),e("p",[t._v("匹配模式：")]),t._v(" "),e("div",{staticClass:"language-react extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('// 精确匹配\n// 严格匹配\n// 大小写敏感\n<Route path="/user" exact component={User} />\n<Route path="/user" strict component={User} />\n<Route path="/user" sensitive component={User} />\n')])])]),e("p",[t._v("路径 path 写法：")]),t._v(" "),e("div",{staticClass:"language-react extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('// 字符串形式\n// 命名参数\n// 数组形式\n<Route path="/user" component={User} />\n<Route path="/user/:userId" component={User} />\n<Route path={["/users", "/profile"]} component={User} />\n')])])]),e("p",[t._v("渲染方式：")]),t._v(" "),e("div",{staticClass:"language-react extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// 通过子组件渲染\n// 通过 props.component 渲染\n// 通过 props.render 渲染\n<Route path='/home'><Home /></Route>\n<Route path='/home' component={Home}></Route>\n<Route path='/home' render={() => <p>home</p>}></Route>\n\n// 例子: 这里最终的渲染结果是User, 优先级是子组件 > component > render\n<Route path='/home' component={Home} render={() => <p>About</p>}>\n  <User />\n</Route>\n")])])]),e("p",[e("code",[t._v("<Route>")]),t._v(" 所做的事情也很简单，匹配到传入的 path，渲染对应的组件。此外 "),e("code",[t._v("<Route>")]),t._v(" 还提供了几种不同的匹配模式、path写法以及渲染方式")]),t._v(" "),e("p",[t._v("Route 提供了三种渲染方式：子组件、"),e("code",[t._v("props.component")]),t._v("、"),e("code",[t._v("props.render")]),t._v("，三者之间又存在优先级，因此就形成了我们看到了多层三元表达式渲染的结构。")]),t._v(" "),e("h2",{attrs:{id:"总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),e("p",[t._v("从后端路由到前端路由，最大的改变是体验，体验更良好了")]),t._v(" "),e("p",[t._v("前端路由模式有两种：hash 模式 和 history 模式，两者分别利用浏览器自由特性实现单页面导航")]),t._v(" "),e("ul",[e("li",[t._v("hash 模式：window.location 或 a 标签改变锚点值，window.hashchange() 监听锚点变化")]),t._v(" "),e("li",[t._v("history 模式：history.pushState()、history.replaceState() 定义目标路由，window.onpopstate() 监听浏览器操作导致的 URL 变化")])]),t._v(" "),e("p",[t._v("React Router 匹配路由由 "),e("code",[t._v("mathPath")]),t._v("  通过 "),e("code",[t._v("path-to-regexp")]),t._v(" 进行，"),e("code",[t._v("<Route>")]),t._v(" 相当于一个高阶组件，以不同的优先级和匹配模式渲染匹配到的子组件")]),t._v(" "),e("p",[t._v("React Router 的主要组件源码，整体的实现：")]),t._v(" "),e("ul",[e("li",[t._v("对于"),e("strong",[t._v("监听")]),t._v("功能的实现，React Router 引入了 "),e("code",[t._v("history")]),t._v(" 库，以屏蔽了不同模式路由在监听实现上的差异, 并将路由信息以 "),e("code",[t._v("context")]),t._v(" 的形式，传递给被 "),e("code",[t._v("<Router>")]),t._v(" 包裹的组件, 使所有被包裹在其中的路由组件都能"),e("strong",[t._v("感知到路由的变化, 并接收到路由信息")])]),t._v(" "),e("li",[t._v("在"),e("strong",[t._v("匹配")]),t._v("的部分， React Router 引入了 "),e("code",[t._v("path-to-regexp")]),t._v(" 来拼接路径正则以实现不同模式的匹配，路由组件·"),e("code",[t._v("<Route>")]),t._v("作为一个高阶组件包裹业务组件, 通过比较当前路由信息和传入的 path，以不同的优先级来渲染对应组件")])]),t._v(" "),e("h2",{attrs:{id:"参考资料"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[t._v("#")]),t._v(" 参考资料")]),t._v(" "),e("ul",[e("li",[e("p",[e("a",{attrs:{href:"https://mp.weixin.qq.com/s/hcAMubPlse4cK9y_-mS5yQ",target:"_blank",rel:"noopener noreferrer"}},[t._v("深入浅出解析React Router源码"),e("OutboundLink")],1)])]),t._v(" "),e("li",[e("p",[e("a",{attrs:{href:"https://github.com/youngwind/blog/issues/109",target:"_blank",rel:"noopener noreferrer"}},[t._v("单页面应用路由实现原理：以 React-Router 为例"),e("OutboundLink")],1)])]),t._v(" "),e("li",[e("p",[e("a",{attrs:{href:"https://github.com/happylindz/blog/issues/4",target:"_blank",rel:"noopener noreferrer"}},[t._v("剖析单页面应用路由实现原理"),e("OutboundLink")],1)])]),t._v(" "),e("li",[e("p",[e("a",{attrs:{href:"https://juejin.cn/post/6895882310458343431",target:"_blank",rel:"noopener noreferrer"}},[t._v("SPA 路由三部曲之核心原理"),e("OutboundLink")],1)])]),t._v(" "),e("li",[e("p",[e("a",{attrs:{href:"https://mp.weixin.qq.com/s/SJXwhTo4j6I3WMmQuOOs7A",target:"_blank",rel:"noopener noreferrer"}},[t._v("SPA 路由三部曲之实战演练"),e("OutboundLink")],1)])]),t._v(" "),e("li",[e("p",[e("a",{attrs:{href:"https://mp.weixin.qq.com/s/xyk9Qla6p2lDsRoqrvasTA",target:"_blank",rel:"noopener noreferrer"}},[t._v("图解 React-router 带你深入理解路由本质"),e("OutboundLink")],1)])])])])}),[],!1,null,null,null);a.default=n.exports}}]);