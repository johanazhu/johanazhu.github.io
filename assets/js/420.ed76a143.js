(window.webpackJsonp=window.webpackJsonp||[]).push([[420],{879:function(e,a,_){"use strict";_.r(a);var v=_(25),l=Object(v.a)({},(function(){var e=this,a=e.$createElement,_=e._self._c||a;return _("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[_("h1",{attrs:{id:"常见面试题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#常见面试题"}},[e._v("#")]),e._v(" 常见面试题")]),e._v(" "),_("p",[e._v("https://mp.weixin.qq.com/s?__biz=Mzg2NDAzMjE5NQ==&mid=2247485446&idx=1&sn=44e1854d1a082d2d3dbed728cbc2661b&chksm=ce6eccaaf91945bce11a50b5805b2826b388aba0df365cbfbac1a6a928ad54233c17f1b1a20d&mpshare=1&scene=1&srcid=&sharer_sharetime=1585271389870&sharer_shareid=778ad5bf3b27e0078eb105d7277263f6#rd")]),e._v(" "),_("h4",{attrs:{id:"_1-有哪些常见的loader-你用过哪些loader"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-有哪些常见的loader-你用过哪些loader"}},[e._v("#")]),e._v(" 1.有哪些常见的loader？你用过哪些loader")]),e._v(" "),_("p",[e._v("raw-loader: 加载文件原始内容")]),e._v(" "),_("p",[e._v("file-loader: 把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件（处理图片和字体）")]),e._v(" "),_("p",[e._v("url-loader: 与 file-loader 类似，区别是用户可以设置一个阈值，大于阈值时返回其publicPath，小于阈值时返回文件 base64 形式编码（处理图片和字体）")]),e._v(" "),_("p",[e._v("source-map-loader： 加载额外的 source map 文件，以方便断点调试")]),e._v(" "),_("p",[e._v("svg-inline-loader: 将压缩后的 svg 内容注入代码中")]),e._v(" "),_("p",[e._v("image-loader: 加载并且压缩图片文件")]),e._v(" "),_("p",[e._v("json-loader：加载 json 文件")]),e._v(" "),_("p",[e._v("babel-loader： 将 es6 转换成 es5")]),e._v(" "),_("p",[e._v("ts-loader：将 typescript 转换成 javascript")]),e._v(" "),_("p",[e._v("awesome-typescript-loader： 将 typescript 转换为 javascript，性能优于 ts-loader")]),e._v(" "),_("p",[e._v("sass-loader: 将 sass 代码转换为 css 代码")]),e._v(" "),_("p",[e._v("css-loader: 加载css，支持模块化、压缩、文件导入等特性")]),e._v(" "),_("p",[e._v("style-loader： 把 css 代码注入到 javascript 中，通过 dom 操作去加载 css")]),e._v(" "),_("p",[e._v("postcss-loader: 扩展 css 语法，使用下一代 css，可以配合 autoprefixer 插件自动补齐 css3 前缀")]),e._v(" "),_("p",[e._v("eslint-loader：通过 eslint 检查 javascript 代码")]),e._v(" "),_("p",[e._v("tslint-loader：通过 tslint 检查 typescript 代码")]),e._v(" "),_("ol",{attrs:{start:"2"}},[_("li",[_("h4",{attrs:{id:"有哪些常见的-plugin-你用过哪些-plugin"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#有哪些常见的-plugin-你用过哪些-plugin"}},[e._v("#")]),e._v(" 有哪些常见的 plugin？你用过哪些 plugin？")])])]),e._v(" "),_("p",[e._v("html-webpack-plugin： 简化 html 文件创建（依赖于html-loader）")]),e._v(" "),_("p",[e._v("uglifyjs-webpack-plugin：不支持 es6 压缩（2.0以上不支持，1.0支持）")]),e._v(" "),_("p",[e._v("terser-webpack-plugin：uglifyjs-webpack-plugin的代替品，支持压缩 es6")]),e._v(" "),_("p",[e._v("mini-css-extract-plugin：分离样式文件，css提取为独立文件，支持按需加载")]),e._v(" "),_("p",[e._v("clean-webpack-plugin：目录清理")]),e._v(" "),_("p",[e._v("webpack-bundle-analyzer：可视化 webpack 输出文件的体积（业务组件、依赖第三方模块）")]),e._v(" "),_("h4",{attrs:{id:"_3-你说一说loader和plugin的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-你说一说loader和plugin的区别"}},[e._v("#")]),e._v(" 3. 你说一说Loader和Plugin的区别")]),e._v(" "),_("p",[e._v("loader 本质就是一个函数，在改函数中对接收到的内容进行转换，返回转换后的结果。因为 Webpack 只认识 JavaScript，所以 Loader 就成了翻译官，对其他类型的资源进行转移的预处理工作")]),e._v(" "),_("p",[e._v("Plugin 就是插件，基于事件流框架 Tapable，插件可以扩展 Webpack 的功能，在 Webpack 运行的生命周期中会广播出许多事件， Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果")]),e._v(" "),_("p",[e._v("Loader 在 module.rules 中配置，作为模块的解析规则，类型为数组。每一项都是一个 Object，内部包含了 test（类型文件）、loader、options（参数）等属性")]),e._v(" "),_("p",[e._v("Plugin 在plugins 中单独配置，类型为数组，每一项是一个 Plugin 的实例，参数都通过构造函数传入")]),e._v(" "),_("h4",{attrs:{id:"_4-webpack-构建流程简单说一下"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-webpack-构建流程简单说一下"}},[e._v("#")]),e._v(" 4.webpack 构建流程简单说一下")]),e._v(" "),_("p",[e._v("webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：")]),e._v(" "),_("p",[e._v("​\t初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数")]),e._v(" "),_("p",[e._v("​\t开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译")]),e._v(" "),_("p",[e._v("​\t确定入口：根据配置中的 entry 找出所有的入口文件")]),e._v(" "),_("p",[e._v("​\t编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖文件都经过了本步骤的处理")]),e._v(" "),_("p",[e._v("​\t完成模块编译：在经过第4步使用的 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及他们之间的依赖关系")]),e._v(" "),_("p",[e._v("​\t输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这部是可以修改输出内容的最后机会")]),e._v(" "),_("p",[e._v("​\t输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统")]),e._v(" "),_("p",[e._v("在以上的过程中， webpack 会在特定的时间点广告处特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 webpack 提供的 API 改变 Webpack 的运行结果")]),e._v(" "),_("p",[e._v("简单的说：")]),e._v(" "),_("p",[e._v("​\t初始化：启动构建，读取与合并配置参数，加载 plugin，实例化 Compiler")]),e._v(" "),_("p",[e._v("​\t编译：从 Entry 出发，针对每个 Module 串行调用对应的 Loader 去翻译文件的内容，再找到该 Module 依赖的 Module，递归地进行便已处理")]),e._v(" "),_("p",[e._v("​\t输出：将编译后的 Module 组合成 Chunk，将 Chunk 转换为文件，输出到文件系统中")]),e._v(" "),_("h4",{attrs:{id:"_5-source-map-是什么-生产环境怎么用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-source-map-是什么-生产环境怎么用"}},[e._v("#")]),e._v(" 5.source map 是什么？生产环境怎么用？")]),e._v(" "),_("p",[e._v("​\tsource map 是讲编译、打包、压缩后的diamante映射回源代码的过程。打包压缩后的代码不具备良好的可读性，想要吊事源码就需要 source map")]),e._v(" "),_("p",[e._v("​\tmap 文件只要不打开开发者工具，浏览器是不会加载的")]),e._v(" "),_("p",[e._v("​\t线上环境一般有三种处理方案：")]),e._v(" "),_("p",[e._v("​\t\thidden-source-map：借助第三方错误监控平台 Sentry 使用")]),e._v(" "),_("p",[e._v("​\t\tnosources-source-map：只会显示具体行数以及查看源代码的错误栈。安全性比 sourcemap 高")]),e._v(" "),_("p",[e._v("​\t\tsourcemap：通过nginx 设置将 .map 文件只对白名单开发（公司内网）")]),e._v(" "),_("p",[e._v("​\t注意：避免在生产中使用 inline- 和 eval- ，因为它们会增加 bundle 体积大小，并降低整体性能")]),e._v(" "),_("h4",{attrs:{id:"_6-模块打包原理知道吗"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-模块打包原理知道吗"}},[e._v("#")]),e._v(" 6.模块打包原理知道吗？")]),e._v(" "),_("p",[e._v("​\twebpack 实际上尉每个模块创造了一个可以导出和导入的环境，本质上并没有修改 代码的执行逻辑，代码执行顺序与模块加载顺序也完全一致。")]),e._v(" "),_("h4",{attrs:{id:"_7-文件监听原理呢"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_7-文件监听原理呢"}},[e._v("#")]),e._v(" 7.文件监听原理呢？")]),e._v(" "),_("p",[e._v("在发现源码发生变化时，自动重新构建出新的输出文件。")]),e._v(" "),_("p",[e._v("webpack 开启监听模式，有两种方式：")]),e._v(" "),_("p",[e._v("​\t启动 webpack 命令时，带上 --watch 参数")]),e._v(" "),_("p",[e._v("​\t在配置 webpack.config.js 中设置 watch：true")]),e._v(" "),_("h4",{attrs:{id:"_8-说一下-webpack-的热更新原理吧-必考"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_8-说一下-webpack-的热更新原理吧-必考"}},[e._v("#")]),e._v(" 8.说一下 webpack 的热更新原理吧（必考）")]),e._v(" "),_("p",[e._v("​\twebpack 的热更新又称热替换（Hot Module Replacement），缩写为 HMR。这个机制可以做到不用刷新浏览器而将新变更的模块替换掉旧的模块。")]),e._v(" "),_("p",[e._v("​\tHMR的核心就是客户端从服务端拉去更新后的文件，准确的说是 chunk diff（chunk 需要更新的部分），实际上 WDS 与浏览器之间维护了一个 "),_("code",[e._v("Websocket")]),e._v(" ，当本地资源发生变化时，WDS 会向浏览器推送更新，并带上构建时的 hash，让客户端与上一次资源进行对比。客户端对比出差异后会向 WDS 发起 "),_("code",[e._v("Ajax")]),e._v(" 请求来获取更新内容（文件列表、hash），这样客户端就可以再借助这些信息继续向 WDS 发起 "),_("code",[e._v("jsonp")]),e._v(" 请求获取该 chunk 的增量更新")]),e._v(" "),_("p",[e._v("后续的部分（拿到增量更新之后如何处理？哪些状态该保留？哪些又需要更新？）由 "),_("code",[e._v("HocModulePlugin")]),e._v(" 来完成，提供了相关 API 以供开发者针对自身场景进行处理，像 "),_("code",[e._v("react-hot-loader")]),e._v(" 和 "),_("code",[e._v("vue-loader")]),e._v(" 都是借助这些 API 实现 HMR。")]),e._v(" "),_("p",[e._v("原理请参考webpack HMR 原理解析")]),e._v(" "),_("h3",{attrs:{id:"_9-如何对bundle体积进行监控和和分析"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_9-如何对bundle体积进行监控和和分析"}},[e._v("#")]),e._v(" 9.如何对bundle体积进行监控和和分析？")]),e._v(" "),_("p",[_("code",[e._v("VSCode")]),e._v(" 中有个插件 "),_("code",[e._v("Import Cost")]),e._v(" 可以帮组我们对引入的模块的大小进行实时监测，还可以和使用 "),_("code",[e._v("webpack-bundle-analyzer")]),e._v(" 生成 "),_("code",[e._v("bundle")]),e._v(" 的模块组成图，显示所占体积")]),e._v(" "),_("p",[_("code",[e._v("bundlesize")]),e._v(" 工具包可以进行自动化资源体积监控")]),e._v(" "),_("h3",{attrs:{id:"_10-文件指纹是什么-怎么用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_10-文件指纹是什么-怎么用"}},[e._v("#")]),e._v(" 10.文件指纹是什么？怎么用？")]),e._v(" "),_("p",[e._v("文件指纹是打包后输出的文件名的后缀")]),e._v(" "),_("ul",[_("li",[_("code",[e._v("Hash")]),e._v(" ：和整个项目的构建相关，只要项目文件有修改，整个项目构建的 hash 值就会更改")]),e._v(" "),_("li",[_("code",[e._v("Chunkhash")]),e._v("：和 webpack 打包的 chunk 有关，不同的 entry 会发出不同的 chunkhas")]),e._v(" "),_("li",[_("code",[e._v("Contenthash")]),e._v("：根据文件内容来定义 hash，文件内容不变，则 contenthash 不变")])]),e._v(" "),_("h3",{attrs:{id:"_11-如何优化-webpack-的构建速度"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_11-如何优化-webpack-的构建速度"}},[e._v("#")]),e._v(" 11.如何优化 webpack 的构建速度？")]),e._v(" "),_("p",[e._v("可以讲很多，我觉得按重要性来说")]),e._v(" "),_("ul",[_("li",[e._v("使用 "),_("code",[e._v("高版本")]),e._v("的 webpack 和 Node.js")]),e._v(" "),_("li",[_("code",[e._v("多进程/多实例构建")]),e._v(": HappyPack（不维护了）、thread-loader")]),e._v(" "),_("li",[e._v("压缩代码\n"),_("ul",[_("li",[e._v("webpack-paralle-uglify-plugin")]),e._v(" "),_("li",[e._v("uglifyjs-webpack-plugin 开启 parallel 参数（不支持ES6）")]),e._v(" "),_("li",[e._v("terser-webpack-plugin 开启 parallel 参数")]),e._v(" "),_("li",[e._v("多进程并行压缩")]),e._v(" "),_("li",[e._v("通过 mini-css-extract-plugin 提取 chunk 中的 css 代码到单独文件，通过 css-loader 的minimize 选项开启 cssnano 压缩 css")])])]),e._v(" "),_("li",[e._v("图片压缩\n"),_("ul",[_("li",[e._v("使用基于 Node 库的 imagemin（很多定制选项、可以处理多种图片格式）")]),e._v(" "),_("li",[e._v("配置 image-webpack-loader")])])]),e._v(" "),_("li",[e._v("缩小打包作用于\n"),_("ul",[_("li",[e._v("exclude/include（确定 loader 规则范围）")]),e._v(" "),_("li",[e._v("resolve.modules 指明第三方模块的绝对路径（减少不必要的查找）")]),e._v(" "),_("li",[e._v("resolve.mainFields 只采用 main 字段作为入口文件描述字段（减少搜索不走，需要考虑到所有运行时依赖的第三方模块的入口文件描述字段）")]),e._v(" "),_("li",[e._v("resolve.extensions 尽可能减少后缀尝试的可能性")]),e._v(" "),_("li",[e._v("noParse 对完全不需要解析的库进行忽略（不去解析但仍会打包到bundle中，被忽略掉的文件里不应该包含 import、require、define 等模块化语句）")]),e._v(" "),_("li",[e._v("IgnorePlugin（完全排除模块）")]),e._v(" "),_("li",[e._v("合理使用alias")])])]),e._v(" "),_("li",[e._v("提取页面公共资源\n"),_("ul",[_("li",[e._v("使用 html-webpack-externals-plugin，将基础包通过 CDN 引入，不打入 bundle 中")]),e._v(" "),_("li",[e._v("使用 splitchunksplugin 进行（公共脚本、基础包、页面公共文件）分离（webpack4内置），替代了 commonschunkplugin 插件")]),e._v(" "),_("li",[e._v("基础包分离")])])]),e._v(" "),_("li",[e._v("DLL：\n"),_("ul",[_("li",[e._v("使用 DllPlugin 进行分包，使用 DllReferencePlugin（索引链接）对 manifest.json 引用，让一些基本不会改动的代码先打包成静态资源，避免反复编译浪费时间")]),e._v(" "),_("li",[e._v("HashedModuleIdsPlugin 可以解决模块数字 id 问题")])])]),e._v(" "),_("li",[e._v("充分利用缓存提升二次构建速度\n"),_("ul",[_("li",[e._v("babel-loader 开启缓存")]),e._v(" "),_("li",[e._v("terser-webpack-plugin 开启缓存")]),e._v(" "),_("li",[e._v("使用 cache-loader 或者 hard-source-webpack-plugin")])])]),e._v(" "),_("li",[e._v("Tree shaking\n"),_("ul",[_("li",[e._v("purgecss-webpack-plugin 和 mini-css-extract-plugin 配合使用（建议）")]),e._v(" "),_("li",[e._v("打包过程中检测工程中没有引用过的模块并进行标记，在资源压缩时将它们从最终的bundle 中去掉（只能对 ES6 Modlue生效）开发中尽可能使用 ES6 Module 的模块，提高 tree shaking 效率")]),e._v(" "),_("li",[e._v("禁用 babel-loader 的模块依赖解析，否则 webpack 接受到的就都是转换过的 CommonJS 形式的模块，无法进行 tree-shaking")])])]),e._v(" "),_("li",[e._v("动态 polyfill\n"),_("ul",[_("li",[e._v("建议采用 polyfill-service 只给用户返回需要的polyfill，社区维护")])])])]),e._v(" "),_("h3",{attrs:{id:"_12-你刚才提到了代码分割-那代码分割的本质是什么-有什么意义呢"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_12-你刚才提到了代码分割-那代码分割的本质是什么-有什么意义呢"}},[e._v("#")]),e._v(" 12.你刚才提到了代码分割，那代码分割的本质是什么？有什么意义呢？")]),e._v(" "),_("p",[e._v("代码分割的本质其实是在"),_("code",[e._v("源代码直接上线")]),e._v(" 和 "),_("code",[e._v("打包成唯一脚本main.bundle.js")]),e._v(" 这两种极端方案之间的一种更适合实际场景的中间状态。")]),e._v(" "),_("p",[_("strong",[e._v("用可接受的服务器性能压力增加来换取更好的用户体验")])]),e._v(" "),_("p",[e._v("源代码直接上线：虽然过程可控，但是http请求多，性能开销大")]),e._v(" "),_("p",[e._v("打包成唯一脚本：一把搜哈自己爽，服务器压力下，但是页面空白期长，用户体验差")]),e._v(" "),_("h3",{attrs:{id:"_13-是否写过loader-简单描述一下编写-loader-的思路"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_13-是否写过loader-简单描述一下编写-loader-的思路"}},[e._v("#")]),e._v(" 13.是否写过Loader？简单描述一下编写 loader 的思路？")]),e._v(" "),_("p",[e._v("Loader 支持链式调用，所以开发商需要严格遵循“单一职责”，每个Loader只负责自己需要负责的事件。")]),e._v(" "),_("p",[e._v("过程：")]),e._v(" "),_("ul",[_("li",[e._v("Loader 运行在Node.js 中，我们可以调用任意 Node.js 自带的API或者安装第三方模块进行调用")]),e._v(" "),_("li",[e._v("Webpack 传给 Loader 的原内容都是 UTF-8 格式编码的字符串，当某些场景下Loader处理二进制文件时，需要通过exports.raw = true 告诉webpack该loader是否需要二进制数据")]),e._v(" "),_("li",[e._v("尽可能的异步 Loader，如果计算量很小，同步也可以")]),e._v(" "),_("li",[e._v("Loader是无状态的，我们不应该在Loader中保留状态")]),e._v(" "),_("li",[e._v("使用 loader-utils 和 schema-utils 为我们提供的使用工具")]),e._v(" "),_("li",[e._v("加载本地 loader 方法\n"),_("ul",[_("li",[e._v("npm link")]),e._v(" "),_("li",[e._v("resolveloader")])])])]),e._v(" "),_("h3",{attrs:{id:"_14-是否写过plugin-简单描述一下编写plugin-的思路"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_14-是否写过plugin-简单描述一下编写plugin-的思路"}},[e._v("#")]),e._v(" 14.是否写过Plugin？简单描述一下编写plugin 的思路")]),e._v(" "),_("p",[e._v("webpack 在运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在特定的阶段钩入想要添加的自定义功能。 webpack 的 tapable 事件流机制保证了插件的有序性，使得整个系统扩展性良好。")]),e._v(" "),_("p",[e._v("过程：")]),e._v(" "),_("ul",[_("li",[e._v("compiler 暴露了和 webpack 整个生命周期相关的钩子")]),e._v(" "),_("li",[e._v("compilation 暴露了与模块和依赖有关的粒度更小的事件钩子")]),e._v(" "),_("li",[e._v("插件需要在其原型上绑定 apply 方法，才能访问 compiler 实例")]),e._v(" "),_("li",[e._v("传给每个插件的 compilter 和 compilation 对象都是同一个引用，若在一个插件中修改了他们身上的属性，会影响后面的插件")]),e._v(" "),_("li",[e._v("找出合适的事件点去完成想要的功能\n"),_("ul",[_("li",[e._v("emit 事件发生时，可以读取到最终输出的资源、代码块、模块及其依赖，并进行修改（emit 事件是修改webpack输出资源的最后时机）")]),e._v(" "),_("li",[e._v("watch-run 当依赖的文件发生变化时会出发")])])]),e._v(" "),_("li",[e._v("异步的事件需要在插件处理完任务时调用回调函数通知webpack进入下一个流程，不然会卡主")])]),e._v(" "),_("h3",{attrs:{id:"_15-聊一聊babel原理吧"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_15-聊一聊babel原理吧"}},[e._v("#")]),e._v(" 15.聊一聊Babel原理吧")]),e._v(" "),_("p",[e._v("大多数 JavaScript Parser 遵循 "),_("code",[e._v("estree")]),e._v(" 规范，Babel 最初基于 "),_("code",[e._v("acorn")]),e._v(" 项目（轻量级现代 JavaScript 解析器） Babel 大概分为三大部分：")]),e._v(" "),_("ul",[_("li",[e._v("解析：将代码转换成 AST\n"),_("ul",[_("li",[e._v("词法分析：将代码（字符串）分割为 token 流，即语法单元成的数组")]),e._v(" "),_("li",[e._v("语法分析：分析 token 流（上面生成的数组）并生成 AST")])])]),e._v(" "),_("li",[e._v("转换：访问 AST 的节点进行变换操作生产新的 AST\n"),_("ul",[_("li",[e._v("Taro 就是利用 babel 完成的小程序语法装换（ https://github.com/NervJS/taro/blob/master/packages/taro-transformer-wx/src/index.ts#L15 ）")])])]),e._v(" "),_("li",[e._v("生成：以新的 AST 为基础生成代码")])]),e._v(" "),_("p",[e._v("想了解如何一步一步实现一个编译器的同学可以移步 Babel 官网曾经推荐的开源项目 the-super-tiny-compiler （ https://github.com/jamiebuilds/the-super-tiny-compiler ）")]),e._v(" "),_("p",[e._v("​")])])}),[],!1,null,null,null);a.default=l.exports}}]);