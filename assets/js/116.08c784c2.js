(window.webpackJsonp=window.webpackJsonp||[]).push([[116],{562:function(v,_,t){"use strict";t.r(_);var e=t(25),n=Object(e.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"let-和-const"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#let-和-const"}},[v._v("#")]),v._v(" let 和 const")]),v._v(" "),t("p",[v._v("https://www.cnblogs.com/zhuzhenwei918/p/6131345.html")]),v._v(" "),t("p",[v._v("我用了两个月的时间才理解 let")]),v._v(" "),t("p",[v._v("https://zhuanlan.zhihu.com/p/28140450")]),v._v(" "),t("p",[v._v("块级作用域和暂时性死区。")]),v._v(" "),t("p",[v._v("之前的var变量，会有变量提升的概念。即你在任何处用var定义变量，一开始js引擎会将其变量置位顶部（以 "),t("code",[v._v("undefined")]),v._v(" 的形式，再执行到赋值时，再赋值）")]),v._v(" "),t("p",[v._v("但是用let、const 声明的变量，则不会有变量提升的概念，在定义let之前，不能调用let声明的变量，不然会报错，在块级作用域的开始到let声明的前一行，这块区域被称为"),t("code",[v._v("暂时性死区")])]),v._v(" "),t("p",[v._v("变量提升和暂时性死区")]),v._v(" "),t("p",[v._v("var会变量提升")]),v._v(" "),t("p",[v._v("function会函数提升")]),v._v(" "),t("p",[v._v("函数提升的优先级大于变量提升")]),v._v(" "),t("p",[v._v("let、const会引起暂时性死区")]),v._v(" "),t("p",[v._v("为什么？")]),v._v(" "),t("p",[v._v("因为")]),v._v(" "),t("p",[v._v("变量提升和暂时性死区算feature(特性)还是bug")]),v._v(" "),t("p",[v._v("ES6规定，let/const 命令会使区块形成封闭的作用域。如在声明之前使用变量，就会报错。")]),v._v(" "),t("p",[v._v("总之，在代码块内，使用 let 命令声明变量之前，该变量都是不可用的。")]),v._v(" "),t("p",[v._v("这在语法上，称为“"),t("strong",[v._v("暂时性死区")]),v._v("”（temporal dead zone，简称TDZ）")]),v._v(" "),t("p",[v._v("也就是说由let、const声明的变量，在使用之前，这些变量都是不可用的")]),v._v(" "),t("p",[v._v("var 声明的会在预编译阶段进行变量提升，并且赋值undefined")]),v._v(" "),t("p",[v._v("非表达式的函数也会进行函数声明，它的优先级大于var")]),v._v(" "),t("p",[v._v("阮一峰：")]),v._v(" "),t("blockquote",[t("p",[v._v("ES6 规定暂时性死区和"),t("code",[v._v("let")]),v._v("、"),t("code",[v._v("const")]),v._v("语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。这样的错误在 ES5 是很常见的，现在有了这种规定，避免此类错误就很容易了。")])]),v._v(" "),t("p",[v._v("作用域")]),v._v(" "),t("p",[v._v("​")]),v._v(" "),t("p",[v._v("代码提升是在预编译阶段进行，而代码执行阶段")]),v._v(" "),t("p",[v._v("预编译阶段会做三件事")]),v._v(" "),t("p",[v._v("​\t变量声明")]),v._v(" "),t("p",[v._v("​\t变量声明并进行提升，但是值为 undefined")]),v._v(" "),t("p",[v._v("​\t所有非表达式的函数声明进行提升（函数声明）")]),v._v(" "),t("p",[t("img",{attrs:{src:"https://i.loli.net/2021/06/04/9uaTpg7C3l8XxNb.png",alt:"image-20210604173150466"}})]),v._v(" "),t("ol",[t("li",[v._v("当脚本开始运行，词法环境预先填充了所有的变量\n"),t("ul",[t("li",[v._v("最初，它们处于“未初始化（Uninitiallized）”状态。这是一种特殊的内部状态，这意味着引擎知道变量，但是在用 "),t("code",[v._v("let")]),v._v(" 声明前，不能引用它。几乎就像变量不存在一样。")])])]),v._v(" "),t("li",[v._v("然后 "),t("code",[v._v("let phrase")]),v._v(" 定义出现了。它尚未被赋值，因此它的值为 "),t("code",[v._v("undefined")]),v._v(" 。从这一刻起，我们就可以使用变量了。")])]),v._v(" "),t("p",[v._v("第一个阶段，就是暂时性死区")]),v._v(" "),t("h3",{attrs:{id:"参考资料"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[v._v("#")]),v._v(" 参考资料")]),v._v(" "),t("p",[t("a",{attrs:{href:"https://zh.javascript.info/closure",target:"_blank",rel:"noopener noreferrer"}},[v._v("闭包"),t("OutboundLink")],1)])])}),[],!1,null,null,null);_.default=n.exports}}]);