(window.webpackJsonp=window.webpackJsonp||[]).push([[321],{778:function(e,t,a){"use strict";a.r(t);var r=a(25),n=Object(r.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"核心-api"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#核心-api"}},[e._v("#")]),e._v(" 核心 API")]),e._v(" "),a("p",[e._v("这里对重要的 API 做介绍")]),e._v(" "),a("h2",{attrs:{id:"概览"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#概览"}},[e._v("#")]),e._v(" 概览")]),e._v(" "),a("h3",{attrs:{id:"组件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#组件"}},[e._v("#")]),e._v(" 组件")]),e._v(" "),a("p",[a("a",{attrs:{href:"#Component"}},[e._v("Component")])]),e._v(" "),a("ul",[a("li",[e._v("构建组件的基类")])]),e._v(" "),a("p",[a("a",{attrs:{href:"#PureComponent"}},[e._v("PureComponent")])]),e._v(" "),a("ul",[a("li",[e._v("与 Component 不同的点在于，它进行了浅对比，即 shouldComponentUpdate 的操作")])]),e._v(" "),a("p",[a("a",{attrs:{href:"#memo"}},[e._v("memo")])]),e._v(" "),a("ul",[a("li",[e._v("高阶组件")]),e._v(" "),a("li",[e._v("缓存操作")])]),e._v(" "),a("h3",{attrs:{id:"refs"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#refs"}},[e._v("#")]),e._v(" Refs")]),e._v(" "),a("p",[a("a",{attrs:{href:"#createRef"}},[e._v("createRef")])]),e._v(" "),a("ul",[a("li",[e._v("创建一个能够通过 ref 属性附加到 React 元素的 ref")])]),e._v(" "),a("p",[a("a",{attrs:{href:"#forwardRef"}},[e._v("forwardRef")])]),e._v(" "),a("ul",[a("li",[e._v("转发，把 ref 转发给下一个组件")])]),e._v(" "),a("h3",{attrs:{id:"fragment"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#fragment"}},[e._v("#")]),e._v(" Fragment")]),e._v(" "),a("p",[a("a",{attrs:{href:"#Fragment"}},[e._v("Fragment")])]),e._v(" "),a("ul",[a("li",[e._v("其包裹作用，但自身不渲染到 DOM 上（不会渲染任何可见的UI）")]),e._v(" "),a("li",[e._v("允许你将子列表分组，而无需向 DOM 添加额外节点")]),e._v(" "),a("li",[e._v("减少不必要嵌套的组件")])]),e._v(" "),a("h3",{attrs:{id:"lazy-suspense"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lazy-suspense"}},[e._v("#")]),e._v(" lazy&Suspense")]),e._v(" "),a("p",[a("a",{attrs:{href:"#lazy"}},[e._v("lazy")])]),e._v(" "),a("ul",[a("li",[e._v("懒加载，本质是返回一个 Promise 实例")])]),e._v(" "),a("p",[a("a",{attrs:{href:"#Suspense"}},[e._v("Suspense")])]),e._v(" "),a("ul",[a("li",[e._v("与 lazy 搭配，在等待加载 lazy 组件时做优雅降低（如 loading 指示器等）")]),e._v(" "),a("li",[e._v("使得组件可以“等待”某些操作结束后，再进行渲染")])]),e._v(" "),a("h3",{attrs:{id:"创建-react-元素"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#创建-react-元素"}},[e._v("#")]),e._v(" 创建 React 元素")]),e._v(" "),a("p",[a("a",{attrs:{href:"#createElement"}},[e._v("createElement")])]),e._v(" "),a("ul",[a("li",[e._v("每个 JSX 元素都是调用 React.createElement 的语法糖")])]),e._v(" "),a("p",[a("a",{attrs:{href:"#createFactory"}},[e._v("createFactory")])]),e._v(" "),a("h3",{attrs:{id:"转换元素"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#转换元素"}},[e._v("#")]),e._v(" 转换元素")]),e._v(" "),a("p",[a("a",{attrs:{href:"#cloneElement"}},[e._v("cloneElement")])]),e._v(" "),a("p",[a("a",{attrs:{href:"#isValidElement"}},[e._v("isValidElement")])]),e._v(" "),a("p",[a("a",{attrs:{href:"#React.Children"}},[e._v("React.Children")])]),e._v(" "),a("ul",[a("li",[e._v("map、forEach、count、only、toArray")])]),e._v(" "),a("h3",{attrs:{id:"其他"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#其他"}},[e._v("#")]),e._v(" 其他")]),e._v(" "),a("p",[a("a",{attrs:{href:"#Context"}},[e._v("Context")])]),e._v(" "),a("ul",[a("li",[e._v("提供一个无需为每层组件手动添加 props，就能在组件树间进行数据传递的方法")])]),e._v(" "),a("p",[a("a",{attrs:{href:"#Portals"}},[e._v("Portals")])]),e._v(" "),a("p",[e._v("Profiler")]),e._v(" "),a("ul",[a("li",[e._v("测量渲染一个 React 应用多久渲染一次以及渲染一次的“代价”")])]),e._v(" "),a("p",[e._v("StrictMode")]),e._v(" "),a("ul",[a("li",[e._v("严格模式。")]),e._v(" "),a("li",[e._v("有助于\n"),a("ul",[a("li",[e._v("识别不安全的生命周期")]),e._v(" "),a("li",[e._v("关于使用过时字符串 ref API 的警告")]),e._v(" "),a("li",[e._v("关于使用废弃的 findDOMNode 方法的警告")]),e._v(" "),a("li",[e._v("检测意外的副作用")]),e._v(" "),a("li",[e._v("检测过时的 context API")])])])]),e._v(" "),a("hr"),e._v(" "),a("h3",{attrs:{id:"component"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#component"}},[e._v("#")]),e._v(" Component")]),e._v(" "),a("p",[e._v("React.Component 是使用 ES6 classes 方式定义 React 组件的基类")]),e._v(" "),a("div",{staticClass:"language-react extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("class Greeting extends React.Component {\n  render() {\n    return <h1>Hello, {this.props.name}</h1>;\n  }\n}\n")])])]),a("h3",{attrs:{id:"purecomponent"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#purecomponent"}},[e._v("#")]),e._v(" PureComponent")]),e._v(" "),a("p",[e._v("React.PureComponent 与 React.Component 很相似。两者的区别在于 React.Component 并未实现 shouldComponentUpdate()，而 React.PureComponent 中以浅对比 props 和 state 的方式实现了该函数")]),e._v(" "),a("h3",{attrs:{id:"memo"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#memo"}},[e._v("#")]),e._v(" memo")]),e._v(" "),a("div",{staticClass:"language-react extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const MyComponent = React.memo(function MyComponent(props) {\n  /* 使用 props 渲染 */\n});\n")])])]),a("p",[e._v("React.memo 为高阶组件")]),e._v(" "),a("p",[e._v("如果你的组件在相同 props 的情况下渲染相同的结果，那么你可以通过将其包装在 React.memo 中调用，以此通过"),a("strong",[e._v("记忆组件")]),e._v("渲染结果的方式来提高组件的性能表现")]),e._v(" "),a("p",[e._v("默认情况下其只会对复杂对象做浅层对比，如果你想要控制对比过程，那么需传入第二个参数")]),e._v(" "),a("div",{staticClass:"language-react extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function MyComponent(props) {\n  /* 使用 props 渲染 */\n}\nfunction areEqual(prevProps, nextProps) {\n  /*\n  如果把 nextProps 传入 render 方法的返回结果与\n  将 prevProps 传入 render 方法的返回结果一致则返回 true，\n  否则返回 false\n  */\n}\nexport default React.memo(MyComponent, areEqual);\n")])])]),a("blockquote",[a("p",[e._v("注意")]),e._v(" "),a("p",[e._v("与 class 组件中 shouldComponentUpdate() 方法不同的是，如果 props 相等，areEqual 会返回 true；如果 props 不相等，则返回 false。这与 shouldComponentUpdate 方法的返回值相反")])]),e._v(" "),a("h2",{attrs:{id:"createref"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#createref"}},[e._v("#")]),e._v(" createRef")]),e._v(" "),a("p",[e._v("React.createRef 创建一个能够通过 ref 属性附加到 React 元素的 ref")]),e._v(" "),a("div",{staticClass:"language-react extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('class MyComponent extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.inputRef = React.createRef();\n  }\n\n  render() {\n    return <input type="text" ref={this.inputRef} />;\n  }\n\n  componentDidMount() {\n    this.inputRef.current.focus();\n  }\n}\n')])])]),a("h3",{attrs:{id:"forwardref"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#forwardref"}},[e._v("#")]),e._v(" forwardRef")]),e._v(" "),a("p",[e._v("React.forwardRef 会创建一个 React 组件，这个组件能够将其接受的 ref 属性转发到其他组件树下的另一个组件中。在如下两种场景中特别有用：")]),e._v(" "),a("ul",[a("li",[e._v("转发 refs 到 DOM 组件")]),e._v(" "),a("li",[e._v("在高阶组件中转发 refs")])]),e._v(" "),a("p",[e._v("React.forwardRef 接受渲染函数作为参数。React 将使用 props 和 ref 作为参数来调用此函数。此函数应返回 React 节点")]),e._v(" "),a("div",{staticClass:"language-react extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('const FancyButton = React.forwardRef((props, ref) => (\n  <button ref={ref} className="FancyButton">\n    {props.children}\n  </button>\n));\n\nconst ref = React.createRef();\n<FancyButton ref={ref}>Click me!</FancyButton>;\n')])])]),a("h3",{attrs:{id:"fragment-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#fragment-2"}},[e._v("#")]),e._v(" Fragment")]),e._v(" "),a("p",[e._v("React.Fragment 组件能够在不额外创建 DOM 元素的情况下，让 render() 方法返回多个元素")]),e._v(" "),a("div",{staticClass:"language-react extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("render() {\n  return (\n    <React.Fragment>\n      Some text.\n      <h2>A heading</h2>\n    </React.Fragment>\n  );\n}\n")])])]),a("p",[e._v("你也可以使用其简写语法 "),a("code",[e._v("<></>")]),e._v("。React v16.2.0 以上支持")]),e._v(" "),a("h3",{attrs:{id:"lazy"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lazy"}},[e._v("#")]),e._v(" lazy")]),e._v(" "),a("p",[e._v("lazy 允许你定义一个动态加载的组件。这有助于缩减 bundle 的体积，并延迟加载在初次渲染时未用到的组件")]),e._v(" "),a("div",{staticClass:"language-react extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// 这个组件是动态加载的\nconst SomeComponent = React.lazy(() => import('./SomeComponent'));\n")])])]),a("p",[e._v("请注意，渲染 lazy 组件依赖该组件渲染树上层的 "),a("code",[e._v("<React.Suspense>")]),e._v(" 组件。这是指定加载指示器（loading indicator）的方法")]),e._v(" "),a("p",[e._v("React.lazy 接受一个函数，这个函数需要动态调用 import()。它必须返回一个 Promise，该 Promise 需要 resolve 一个 default export 的 React 组件")]),e._v(" "),a("blockquote",[a("p",[e._v("注意")]),e._v(" "),a("p",[e._v("使用 React.lazy 的动态引入特征需要 JS 环境支持 Promise。在 IE11 及以下版本的浏览器中需要引入 polyfill 来使用该特征")])]),e._v(" "),a("h3",{attrs:{id:"suspense"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#suspense"}},[e._v("#")]),e._v(" Suspense")]),e._v(" "),a("p",[e._v("React.Suspense 可以指定加载指示器（loading indicator），以防其组件树种的某些子组件尚未具备渲染条件，目前，懒加载组件是 "),a("code",[e._v("React.Suspense")]),e._v(" 支持的唯一用例：")]),e._v(" "),a("div",{staticClass:"language-react extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// 该组件是动态加载的\nconst OtherComponent = React.lazy(() => import('./OtherComponent'));\n\nfunction MyComponent() {\n  return (\n    // 显示 <Spinner> 组件直至 OtherComponent 加载完成\n    <React.Suspense fallback={<Spinner />}>\n      <div>\n        <OtherComponent />\n      </div>\n    </React.Suspense>\n  );\n}\n")])])]),a("p",[e._v("fallback 属性接受任何在组件加载过程中你想展示的 React 元素，你可以将 Suspense 组件置于懒加载组件之上的任何位置。你甚至可以用一个 Subspense 组件包裹多个懒加载组件")]),e._v(" "),a("div",{staticClass:"language-react extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("import React, { Suspense } from 'react';\n\nconst OtherComponent = React.lazy(() => import('./OtherComponent'));\nconst AnotherComponent = React.lazy(() => import('./AnotherComponent'));\n\nfunction MyComponent() {\n  return (\n    <div>\n      <Suspense fallback={<div>Loading...</div>}>\n        <section>\n          <OtherComponent />\n          <AnotherComponent />\n        </section>\n      </Suspense>\n    </div>\n  );\n}\n")])])]),a("h3",{attrs:{id:"createelement"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#createelement"}},[e._v("#")]),e._v(" createElement")]),e._v(" "),a("p",[e._v("我们使用的 JSX 语法，是 createElement 的语法糖")]),e._v(" "),a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[e._v("React"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("createElement")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("\n\ttype"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v("props"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("...")]),e._v("children"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n")])])]),a("p",[e._v("创建并返回指定类型的新 React 元素。其中类型参数既可以是标签名、字符串（如 'div' 或 ‘span'），也可以是 React 组件类型（class组件或函数组件），亦或是 React.Frament 类型")]),e._v(" "),a("h3",{attrs:{id:"createfactory"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#createfactory"}},[e._v("#")]),e._v(" createFactory")]),e._v(" "),a("div",{staticClass:"language-react extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("React.createFactory(type)\n")])])]),a("p",[e._v("返回用于生成指定类型 React 元素的函数")]),e._v(" "),a("p",[e._v("现已废弃")]),e._v(" "),a("h3",{attrs:{id:"cloneelement"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cloneelement"}},[e._v("#")]),e._v(" cloneElement")]),e._v(" "),a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[e._v("React"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("cloneElement")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("\n\telement"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v("config"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("...")]),e._v("children"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n")])])]),a("p",[e._v("以 element 元素为样板克隆并返回新的 React 元素。config 中应包含新的 props，key 或 ref。返回元素的 props 是将新的 props 与原始元素的 props 浅层合并后的结果。新的子元素将取代现有的子元素，如果在 config 中未出现 key 或 ref，那么原始元素的 key 和 ref 将被保留")]),e._v(" "),a("p",[e._v("React.cloneElement() 几乎等同于：")]),e._v(" "),a("div",{staticClass:"language-react extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("<element.type {...element.props} {...props}>{children}</element.type>\n")])])]),a("h3",{attrs:{id:"isvalidelement"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#isvalidelement"}},[e._v("#")]),e._v(" isValidElement")]),e._v(" "),a("div",{staticClass:"language-react extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("React.isValidElement(object)\n")])])]),a("p",[e._v("验证对象是否为 React 元素，返回值为 true 或 false")]),e._v(" "),a("h3",{attrs:{id:"children"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#children"}},[e._v("#")]),e._v(" Children")]),e._v(" "),a("p",[e._v("React.Children 提供了用于处理 this.props.children 不透明数据结构的使用方法")]),e._v(" "),a("h4",{attrs:{id:"react-children-map"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-children-map"}},[e._v("#")]),e._v(" React.Children.map")]),e._v(" "),a("div",{staticClass:"language-react extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("React.Children.map(children, function[(thisArg)])\n")])])]),a("p",[e._v("在 children 里的每个直接子节点上调用一个函数，并将 this 设置为 thisArg。如果 children 是一个数组，它将被遍历并为数组中的每个子节点调用该函数。如果子节点为 null 或是 undefined，则此方法将放回 null 或是 undefined，而不会返回数组")]),e._v(" "),a("h4",{attrs:{id:"react-children-foreach"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-children-foreach"}},[e._v("#")]),e._v(" React.Children.forEach")]),e._v(" "),a("div",{staticClass:"language-react extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("React.Children.forEach(children, function[(thisArg)])\n")])])]),a("p",[e._v("与 React.Children.map() 类似，但它不会返回一个数组")]),e._v(" "),a("h4",{attrs:{id:"react-children-count"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-children-count"}},[e._v("#")]),e._v(" React.Children.count")]),e._v(" "),a("div",{staticClass:"language-react extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("React.Children.count(children)\n")])])]),a("p",[e._v("返回 children 中的组件总数量")]),e._v(" "),a("h4",{attrs:{id:"react-children-only"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-children-only"}},[e._v("#")]),e._v(" React.Children.only")]),e._v(" "),a("div",{staticClass:"language-react extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("React.Children.only(children)\n")])])]),a("p",[e._v("验证 children 是否只有一个子节点（一个 React 元素），如果有则返回它，否则此方法会抛出错误")]),e._v(" "),a("h4",{attrs:{id:"react-children-toarray"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-children-toarray"}},[e._v("#")]),e._v(" React.Children.toArray")]),e._v(" "),a("div",{staticClass:"language-react extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("React.Children.toArray(children)\n")])])]),a("p",[e._v("将 children 这个复杂的数据结构以数组的方式扁平展开并返回，并为每个子节点分配一个 key。当你想要在渲染函数中操作子节点的集合时，它会非常使用")]),e._v(" "),a("h3",{attrs:{id:"context"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#context"}},[e._v("#")]),e._v(" Context")]),e._v(" "),a("p",[e._v("Context 提供了一个无需为每层组件手动添加 props，就能在组件数间进行数据传递的方法")]),e._v(" "),a("h4",{attrs:{id:"使用方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用方法"}},[e._v("#")]),e._v(" 使用方法")]),e._v(" "),a("ol",[a("li",[e._v("先注册一个变量")])]),e._v(" "),a("div",{staticClass:"language-react extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('const ThemeContext = React.createContext("light")\n')])])]),a("ol",{attrs:{start:"2"}},[a("li",[e._v("在要用的地方注入")])]),e._v(" "),a("div",{staticClass:"language-react extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('<ThemeContext.Provider value="dark">\n    <Test />\n</ThemeContext.Provider>\n')])])]),a("ol",{attrs:{start:"3"}},[a("li",[e._v("使用")])]),e._v(" "),a("div",{staticClass:"language-react extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("<ThemeContext.Consumer>\n    {value => (\n        <div>{value}</div>\n    )}\n</ThemeContext.Consumer>\n")])])]),a("p",[e._v("Provider负责提供context，而Consumer用来消费Provider提供的context")]),e._v(" "),a("h3",{attrs:{id:"portals"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#portals"}},[e._v("#")]),e._v(" Portals")]),e._v(" "),a("p",[e._v("Protal 提供了一种将子节点但渲染到父组件意外的 DOM 节点的方案")]),e._v(" "),a("div",{staticClass:"language-react extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("React.createPortal(child, container)\n")])])]),a("p",[e._v("第一个参数（child）是任何可渲染的 React 子元素，例如一个元素，字符串或 Fragmen。第二个参数（container）是一个 DOM 元素")]),e._v(" "),a("p",[e._v("一般用在 对话框、提示框组件上")]),e._v(" "),a("p",[a("a",{attrs:{href:"https://codepen.io/gaearon/pen/yzMaBd",target:"_blank",rel:"noopener noreferrer"}},[e._v("在 CodePen 上尝试"),a("OutboundLink")],1)]),e._v(" "),a("h2",{attrs:{id:"参考资料"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[e._v("#")]),e._v(" 参考资料")]),e._v(" "),a("p",[a("a",{attrs:{href:"https://zh-hans.reactjs.org/docs/react-api.html#createelement",target:"_blank",rel:"noopener noreferrer"}},[e._v("React 官网"),a("OutboundLink")],1)]),e._v(" "),a("p",[a("a",{attrs:{href:"https://mp.weixin.qq.com/s/-WLQPNHF2zzPB1v1Lwkw1w",target:"_blank",rel:"noopener noreferrer"}},[e._v("React万字基础全面剖析"),a("OutboundLink")],1)]),e._v(" "),a("p",[a("a",{attrs:{href:"https://mp.weixin.qq.com/s/0SBeDkpp_DYS8uAnYL3AiQ",target:"_blank",rel:"noopener noreferrer"}},[e._v("React 系统复习如何做最高效"),a("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=n.exports}}]);